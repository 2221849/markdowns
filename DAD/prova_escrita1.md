# Distributed Application Development

## Server Processing and Client Processing - Web Application Processing Distribution

### Web Architecture

Web architecture involves the structure and design of web systems, including components like servers, clients, and their interaction. It encompasses how information flows between these elements to deliver web services efficiently.

#### Client-Server Architecture

**Client-Server Interaction**:

- Clients request resources from the server via HTTP requests.
- Servers respond to client requests with HTTP responses.

**Resource Types**:

- Servers provide resources such as HTML documents, images, CSS files, JavaScript files, fonts, and data (XML, JSON, etc.).
- Clients consume these resources from the server to display to users.

**Server Processing vs. Client Processing**:

- Server processing involves handling requests and providing resources.
- Client processing includes rendering content, user interaction, and consuming data from the server.

#### N:M relation

**N:M Relation between Web Clients and Servers**:

- Servers provide resources to multiple clients.
- Clients consume resources from multiple servers.

**Example of N:M Relation in Web Page Resources**:

- A single web page can use resources from multiple servers.
- Resources like HTML documents, images, CSS files, and JavaScript files can be fetched from different servers by the web client to render the web page.

#### HTTP Protocol

- HTTP, or HTTPS, is the message protocol for Web interaction.
- It works in pairs of Request/Response.
- HTTP is stateless, meaning the server doesn't retain user information across requests.

#### HTTP/2 and HTTP/3 Protocol

**HTTP/2**:

- Protocol ratified by the IETF in 2015
- Primary goal is to reduce latency by enabling full multiplexing through a single TCP connection

**HTTP/3**:

- Still in the proposal phase but supported by a large portion of browsers
- Built on QUIC, a UDP-based protocol, instead of TCP like previous versions

### Server Processing

- The web client is unaware of how the response is generated by the server.
- To the web client, a response from a static HTML file or dynamically processed HTML appears the same.
- The web client solely focuses on the response content, such as an HTML document.

#### Server Handling Requests

Server handling requests involves creating responses (HTTP Responses) and sending them to the client. Responses are generated by copying files or processing code on the server. Files like HTML documents, images, and CSS are typically copied to the HTTP Response body.

Server-side languages such as PHP, Java, C#, and Python are used for processing code and generating dynamic content for the HTTP Response. This can include generating HTML documents with data from a database or updating records on a database.

### Client Processing

Client processing involves modifying the elements of a document dynamically without changing the HTML code itself. This is done by manipulating the DOM tree dynamically.

In client processing, JavaScript is commonly used to modify web pages locally on the browser, providing a dynamic user experience.

### Server and Client Resources

**Server Resources**:

- Server resources include server files, database server, email server, and other types of servers like queue and cache servers.
- These resources are typically protected, and the client can only access them indirectly through HTTP responses from the server.

**Client Resources**:

- Clients can access resources sent from the server, DOM elements, browser window, history, local and session storage, cookies, and more.
- Browser and client code (JavaScript) interact with these resources to render web pages for users.

The server sends resources to the client, such as HTML documents, images, CSS, JavaScript code, data (XML, JSON, etc.), and streams (video, audio, etc.).

#### Resources from the Server

The server sends resources to the client, such as HTML documents, images, CSS, JavaScript code, data (XML, JSON, etc.), and streams (video, audio, etc.).

All these resources are transmitted through HTTP responses from the server to the client for rendering on the web page.

#### Resources on the Server

- The server hosts various resources such as server files, database server, email server, and other types of servers like queue and cache servers.
- These resources are typically protected, and clients can only access them indirectly through HTTP responses from the server.

#### Resources on the Client

- The client-side resources that can be accessed by the browser and client code include resources sent from the server, the DOM (Document Object Model) elements, browser window, history, local and session storage, and cookies.
- These resources are essential for the client-side processing and interaction with the server, enabling the client to display web content effectively to users.

### Server and Client Interaction

- The server interacts with the client by responding to HTTP requests made by the client.
- The server cannot directly access resources on the client such as DOM, History, or Local Storage.
- Communication between the server and client is initiated by the client through HTTP requests.

#### Client Interaction with Server

When interacting with the server, the client code (JavaScript) cannot directly access protected resources on the server such as the database server or server files. Instead, the client must access these resources indirectly through the Web Server, which provides a service to abstract the required resource.

To obtain data from a database on the server, the Web server must retrieve the necessary data from the DB and then return it to the client in the form of a data resource (JSON or XML data).

#### Server Interaction with Client

**Server Limitations**:

- The server cannot access resources on the client like DOM, History, or Local Storage.
- Contrary to the client, the server cannot initiate communication with the client directly.

**Client Pull Protocol**:

- HTTP is a pull protocol where the client pulls data from the server, not the other way around.
- The server can only create an HTTP response after receiving a request from the client.

**Push Technologies**:

- While the server cannot contact the client explicitly, it can use push technologies like WebSockets.
- These technologies allow the server to initiate communication with the client in real-time.

## Web Application Models - Multi-page, Single-page and Hybrid models

### Multi-Page Application

- The Multi-Page Application Model is a traditional web application model where application processing mainly occurs on the server.
- Users interact with the application by either getting a new page with a different URL or the same page with different content, which is essentially a new page.
- In this model, the server creates and sends a new page to the client for any content update, whether it's a completely new page or partial changes on a page.

**Limitations**:

- Bad User Experience: Continuous page re-rendering negatively impacts user experience by exposing network latency.
- Poor Performance: Unnecessary data re-transmission occurs due to complete page reloads with each user interaction.
- Lack of Offline Support: The web application becomes useless when server connectivity is lost.

### Single Page Application

- A Single Page Application (SPA) is a web application that loads a single HTML page and updates it dynamically as the user interacts with the app.
- Examples of SPAs include Gmail, Google Maps, Google Drive, iCloud, GitHub, Hotmail, Soundcloud, and Trello.

**Client-Side and Server-Side Processing**:

- In a typical SPA, the client-side code (JavaScript) renders content, handles user interaction, and consumes data from the web server.
- The server-side is responsible for providing data to the clients and executing business-related operations on client demand.

**Local Content Handling and Latency**:

- SPAs handle content updates locally using JavaScript code, resulting in reduced latency and almost instant content updates.
- The server's role in SPAs is to provide data and operations to the client, without handling content updates.

**Online and Offline Models**:

- SPA applications can support an online model where they consume data and execute operations on the server.
- Some SPAs also support an offline model, operating offline and synchronizing data with the server when online.

### Hybrid Application

**Advantages of Hybrid Model**:

- Combines benefits of SPA with responsiveness and performance.
- Allows for instant content updates locally using JavaScript.

**Limitations of Hybrid Model**:

- Lacks smooth and continuous navigation like SPA.
- Slow initial loads on multiple pages compared to SPA's single initial load.

### Model Comparison

- The Hybrid Application Model shares advantages with Single-Page Application (SPA) in terms of responsiveness and performance but lacks smooth navigation and offline capabilities.
- It addresses some limitations of the SPA model like Search Engine Optimization and client/server code partitioning but worsens the initial load issue by having slow loads on multiple pages.

### Progressive Web App

A progressive web app (PWA) is a single-page web application designed to look and function like a mobile app. It utilizes web technologies such as service workers, manifests, and notification APIs to provide an app-like experience.

PWAs can be accessed instantly through a web browser without the need to download from an app store. They follow the principle of progressive enhancement, offering essential content to all users while delivering a top-notch experience to modern browsers.

### Rendering Strategies

**Client-side Rendering**:

- JavaScript fully renders the page using a Virtual DOM.
- Prominent Frameworks: Vue.js, React.

**Incremental Static Regeneration**:

- Regenerate specific pages or fragments after the initial static rendering.
- Prominent Framework: NextJS.

**Partial Hydration**:

- On-demand hydration of parts of the client-side application after the initial server-side render.
- Prominent Framework: Laravel Livewire.

**Islands Architecture**:

- Relies on static HTML base and independent "islands" of interactivity.
- Prominent Framework: Astro.

**Resumability**:

- Serialization of server-side application state for client-side resumability.
- Prominent Framework: Qwik.

**HATEOAS**:

- Defines application state directly on the DOM using supported mechanisms.
- Prominent Framework: HTMX.

## JavaScript - Syntax and core concepts

### Introduction

#### Why JavaScript?

JavaScript is a ubiquitous language on Web Browsers, used directly or indirectly in various domains such as OpenOffice, Game Engines, Internet of Things, and more. It is supported by modern Web Browsers and server-side technologies like node.js. JavaScript's versatility and wide adoption make it a fundamental language for web development.

#### JavaScript engines

JavaScript engines are virtual machines that interpret and execute JavaScript code. They play a crucial role in the speed of JavaScript execution within web browsers.

Some well-known JavaScript engines include V8 (used in Google Chrome, Opera, and Microsoft Edge), SpiderMonkey (used in Mozilla Firefox), and JavaScriptCore (used in Apple Safari and Node.JS server).

### Basic Syntax and Semantic

#### JavaScript Syntax

JavaScript syntax includes case sensitivity, comments, Unicode charset, and Unicode escape sequences. Semicolons are optional in JavaScript. Control statements and loop syntax are based on the C language family. Objects in JavaScript are a collection of properties, and if a property value is a function, it is known as a method.

JavaScript syntax also includes if statements with conditions and optional else blocks. Objects in JavaScript follow a prototype-based programming paradigm, allowing for object extension by adding properties dynamically. JavaScript does not have classes or class inheritance natively, but ES6 supports these concepts using prototypes internally.

#### Variables and Constants in JavaScript

**Variables Declaration**:

- Variable declaration in JavaScript is optional but recommended.
- It is preferable to declare variables using `let` or `var` .

**Constants Declaration**:

- Constants are declared using `const` keyword in JavaScript.
- Once assigned, the value of a constant cannot be changed.

**Scope of Variables**:

- `let` and `var` have different scopes in JavaScript.
- `var` has function scope while let has block scope.

**Undefined in JavaScript**:

- `undefined` is a literal in JavaScript with only one value.
- It represents the absence of a value and can be assigned to variables.

#### Lexical Scope

In JavaScript, lexical scope refers to the concept where an inner function has access to the scope of the outer function it is contained within. This means that the inner function can access its own local variables, the variables of the outer function, and global variables. Lexical scope allows for nested functions to access variables from their containing functions.

#### Naming Rules and Conventions

Identifiers in JavaScript can include letters, digits, $, and _. They cannot start with a digit or contain spaces or hyphens. It is recommended not to use $ or _ at the beginning or end of a name. The camelCase convention should be followed, with constructor functions starting with a capital letter.

### Data Types

**Primitive Types**:

- Strings are used to represent characters.
- Numbers are internally handled as floating-point values.
- BigInt is a new type introduced in ES2020.
- Booleans, null, and undefined are also primitive types in JavaScript.

**Dynamic Type System**:

- JavaScript has a dynamic type system where variable types are not declared.
- Variables can change their type over time.
- Types are automatically converted to match the expression's expectations, which can lead to unexpected results for inexperienced programmers.

**Explicit Type Conversion**:

- JavaScript provides functions for explicit type conversion.
- Examples include converting a number to a string, a string to a number, and a value to a boolean.
- In situations where type conversion needs to be controlled, explicit conversion functions can be used.

#### Wrapping Objects

Wrapping objects in JavaScript involves wrapping primitive type values on objects. For example, the String object wraps a string value, allowing operations like getting the length of a string.

When working with objects in JavaScript, primitive types values can be wrapped on objects to enable additional functionalities and operations.

#### Strings

String literals in JavaScript can be defined using single quotes, double quotes, or backticks. Strings are immutable, meaning they cannot be changed once created. For example, let str = "abc"; accesses the first character of the string using str[0].

Concatenation in JavaScript is done using the + operator, which can combine strings together. It's important to note that the + operator is used for both concatenation and addition. For instance, "a" + 'b' results in "ab", while 16 + "4" gives "164" due to concatenation.

Template literals in JavaScript are enclosed by backticks (`) and allow for easy text interpolation using ${expression}. This feature is useful for creating multi-line strings and embedding variables within a string. For example,

Hello ${customer}, do you want to buy ${cart.amount} ${cart.product} for a total of ${cart.amount * cart.unitprice} bucks?`.

#### Numbers

JavaScript supports various types of numbers, including integers, decimals, and special values like Infinity and NaN. These numbers can be represented in different formats such as base 12, scientific notation, and BigInt with the 'n' suffix.

In JavaScript, you can work with numbers in different ways, from simple arithmetic operations to handling special values like Infinity and NaN.

#### Booleans

Booleans in JavaScript have only two possible values: true and false. When expressions are evaluated in a Boolean context, they are converted to either true or false values. Falsy values are converted to false, while truthy values are converted to true. All other values that are not falsy are considered truthy and converted to true.

#### Null

**Null Value Representation**:

- Null in JavaScript represents an empty value, assigned explicitly to variables.
- When a variable is assigned a null value, its type becomes null, but it is also considered an empty object.

**Null vs Undefined**:

- Null represents an object or property that exists but holds no value.
- Undefined, on the other hand, represents the absence of an object or property in JavaScript.

#### Undefined

Undefined has only one value in JavaScript, which represents the absence of a value. It occurs when a variable is declared but not assigned any value. This value can be explicitly assigned to a variable, making its type "undefined."

#### Operators

JavaScript provides several types of operators:

- **Arithmetic Operators**: These include addition (+), subtraction (-), multiplication (*), division (/), remainder (%), increment (++), and decrement (--).
- **Assignment Operators**: Used for assigning values and performing arithmetic operations in one step, such as simple assignment (=), addition assignment (+=), subtraction assignment (-=), multiplication assignment (*=), division assignment (/=), and remainder assignment (%=).
- **String Operators**: Mainly used for concatenating strings. This involves concatenation (+) and addition concatenation (+=).
- **Bitwise Operators**: These perform operations on the binary representations of numbers and include AND (&), OR (|), XOR (^), NOT (~), left shift (<<), right shift (>>), and zero-filled right shift (>>>).
- **Logical Operators**: Used for evaluating conditions, including logical AND (&&), logical OR (||), and logical NOT (!).
- **Comparison Operators**: These are used to compare values and determine their relationship. They include:
  - **Equal (==)**: Checks if two values are equal.
  - **Not Equal (!=)**: Checks if two values are not equal.
  - **Strict Equal (===)**: Checks if two values are equal and of the same type.
  - **Strict Not Equal (!==)**: Checks if two values are not equal or not of the same type.
  - **Greater Than (>)**: Checks if the left value is greater than the right value.
  - **Greater Than or Equal (>=)**: Checks if the left value is greater than or equal to the right value.
  - **Less Than (<)**: Checks if the left value is less than the right value.
  - **Less Than or Equal (<=)**: Checks if the left value is less than or equal to the right value.

### Loop and Control Statements

Loop and control statements in JavaScript share a similar syntax with other languages in the C family, such as C, Java, C#, and C++. They include:

**Conditional and Looping Structures**:

- If-Else Statements: Used for conditional execution, allowing code blocks to run based on whether a specified condition is true or false.
- While Loops: Repeatedly execute a block of code as long as a given condition is true.
- Do-While Loops: Similar to while loops, but the code block executes at least once before the condition is checked.
- For Loops: Provide a concise way to perform a specific number of iterations or iterate over array elements.

**For...Of Loop**:

- The `for...of` loop simplifies iterating over the elements of an iterable object, such as arrays, maps, and sets. It eliminates the need to manually manage the index, making the code more readable and easier to maintain. This loop is often preferred over traditional index-based `for` loops when iterating through elements.

**Break and Continue Statements**:

- The `break` statement terminates the loop entirely, stopping further iterations.
- The `continue` statement skips the current iteration and proceeds to the next one. These statements help control the flow within loops based on certain conditions.

### Arrays

In JavaScript, array literals are created using square brackets [] and can contain various types of values, such as strings, numbers, booleans, null, undefined, objects, and even other arrays. Arrays are zero-indexed, meaning the first element is at index 0, and the last element is located at array.length - 1.

When looping over arrays, it is recommended to use `for .. of` loops or `forEach` callbacks instead of traditional numeric-based for loops.

### Objects

JavaScript uses a simple object-based paradigm where an object is a collection of properties. If a property value is a function, it is known as a method. Objects can be extended by adding properties to them.

Prototype-based programming is used in JavaScript, where objects are reused by cloning existing objects that serve as prototypes. Object properties are dynamic, similar to variables, and can be extended by adding new properties or methods.

#### Creating New Objects

Using Constructor Functions:

- Constructor functions in JavaScript are conventionally named with a capital initial letter.
- Inside the constructor function, the `this` keyword is used to assign values to the object's properties.

Calling Constructor Functions:

- To create a new object instance, the constructor function is called using the new operator.
- This process returns a `new` object instance with the specified properties initialized.

Cloning Objects:

- Objects can be cloned using `Object.create()` to create a new object based on an existing one.
- By cloning objects, you can create separate instances with shared or modified properties.

#### Methods

Methods in JavaScript are properties assigned to functions. They can be defined using anonymous functions and utilize the 'this' keyword to refer to the current object. Objects in JavaScript are collections of properties, and if a property value is a function, it is considered a method.

#### Shorthand

**Property Shorthand**:

- Property shorthand in JavaScript allows for concise object creation using existing variable names.
- It simplifies the process by automatically assigning variables as object properties.

**Method Shorthand**:

- Method shorthand provides a shorter syntax for defining functions within objects.
- It streamlines the creation of object methods by omitting the function keyword.

#### Extending Objects

Objects in JavaScript can be extended by adding new properties or methods to them. This can be done by simply defining the new property/method and assigning it to the object.

To extend an object, you can also clone an existing object and then add new properties or methods to the cloned object. This allows for easy modification and extension of objects in JavaScript.

### Functions

JavaScript functions are first-class functions in JavaScript, allowing for various functionalities such as assigning functions to variables, properties, or storing them in collections. They can also be used as parameters of other functions and as return values of other functions.

Functional programming concepts in JavaScript, like callback functions, are supported due to JavaScript's first-class functions. Callback functions are essential in functional programming and are commonly used in JavaScript for various operations.

#### Types of Functions

**Named Functions**:

- These are functions with a specific name defined using the `function` keyword.
- **Example**: `function square(number) { return number * number }`

**Anonymous Functions**:

- Functions without a specific name, often assigned to variables or object properties.
- **Example**: `let sqr = function (a) { return a * a }`

**Arrow Functions**:

- Modern concise syntax for writing functions in JavaScript using `=>` .
- **Example**: `let f = (x, y) => { return x + y }`

**Callback Functions**:

- Functions passed as arguments to other functions, commonly used in functional programming.
- **Example**: `arr.forEach((element, idx) => { console.log(idx + " – " + element); })`

#### Parameter Mismatch

In JavaScript, a function can be called with more or fewer arguments than defined parameters, where extra arguments are ignored in the function's parameter list. However, these additional arguments can still be accessed using the arguments object, which is an array-like structure containing all arguments passed to the function. If fewer arguments are provided, the missing parameters are assigned undefined. Modern JavaScript also supports rest parameters (...args), which collect all extra arguments into an array, allowing for flexible handling of varying numbers of arguments.

#### Arrow Functions - Scope of "this"

Arrow functions in JavaScript maintain their lexical scope, meaning the value of this inside an arrow function is determined by the surrounding context in which the function is defined, rather than how it is called. This behavior contrasts with regular functions, where this can change depending on the call site, often leading to unexpected results. As a result, arrow functions provide a more predictable and consistent behavior for this, making them especially useful in scenarios like callbacks or event handlers where maintaining the correct context is crucial. This characteristic allows developers to avoid common pitfalls associated with the dynamic nature of this in traditional function expressions.

## DOM - Document Object Model (DOM)

### DOM

- The Document Object Model (DOM) is an API that represents the HTML document as a tree structure in all browsers.
- JavaScript uses DOM methods to manipulate the structure, style, or content of the document, with changes reflected visually on the browser.

#### Alternatives

DOM works as a low-level API for content manipulation in the browser. However, various libraries and frameworks offer their own rendering methods that encapsulate the DOM API. Examples include jQuery, Vue.js, Angular, and React.js.

These alternatives provide different abstractions and paradigms for manipulating content, but internally, they still rely on the DOM API for rendering.

#### Nodes

DOM nodes are essential components of the Document Object Model (DOM) and can be categorized into four main types: document, element, attribute, and text. Each type serves a specific purpose within the structure of an HTML page. The document node represents the entire HTML document, while element nodes correspond to HTML elements such as `<html>`, `<body>`, `<p>`, `<a>`, and `<div>`. Attribute nodes are associated with specific attributes of elements, like src for `<img>` tags, and text nodes represent blocks of text within the HTML document.

#### Typical Operations

**Selection**: To get the reference of one or more DOM nodes.

**Manipulation**: Reading and changing DOM nodes' state using node properties or methods, as well as changing the DOM structure by deleting or creating new DOM nodes.

**Event Handling**: Creating event handlers (JavaScript functions) and associating them with DOM nodes events.

##### Selection

The Selection in DOM involves various methods to retrieve specific elements within the document or a node. These methods include getElementById, querySelector, getElementsByTagName, and getElementsByClassName.

Each method serves a unique purpose in selecting elements based on IDs, CSS selectors, tag names, or classes, allowing for efficient manipulation and interaction with the DOM.

**Direct Node References**:

- `node.parentNode` - Reference to the parent of the specified node.
- `node.childNodes` - A collection with the direct descendants of the specified node.
- `node.firstChild` / `node.lastChild` - Reference to the first and last child of the specified node.
- `node.previousSibling` / `node.nextSibling` - Reference to the previous and next sibling (brother) of the specified node. Sibling nodes have the same parent DOM.

##### Manipulation

JavaScript manipulates the page content using the DOM API by changing the document's structure, style, or content. These manipulations are reflected visually in the browser. Typical DOM manipulation tasks include modifying element attributes (e.g., updating an image's `src`), changing text content, toggling CSS classes to alter styles dynamically, adding new elements to the document, and removing existing elements. These operations enable dynamic updates to the user interface, allowing for interactive and responsive web pages.

##### Event Handling

Event handling in JavaScript involves attaching event listeners to elements in the DOM. This allows specific actions to be triggered when events like clicks occur on those elements. For example, a click event on a button can be handled by changing the source of an image.

Callback functions play a crucial role in event handling. They are functions passed as parameters to other functions, which can then be invoked when a specific event occurs. In JavaScript, callback functions are commonly used with methods like addEventListener to respond to user interactions.

### Shadow DOM & Virtual DOM

#### Shadow DOM

**Definition**: The Shadow DOM API in modern browsers allows for better encapsulation by handling smaller parts of the document separately, such as Web Components or Widgets, isolating them from each other and the main DOM tree. This isolation ensures that styles created within a single Shadow DOM element remain contained within that scope.

**Benefits**: Components within the Shadow DOM are isolated, preventing interference with the rest of the DOM tree. This eliminates concerns about class naming conventions affecting other parts of the document, providing a more controlled and encapsulated environment for web development.

#### Virtual DOM

- The Virtual DOM is a technique used by frameworks to enhance the speed and efficiency of DOM updates.
- It replicates the real DOM tree structure and allows for inexpensive update operations, improving performance by updating only the necessary portions of the view.

## Vue.js

### Main Concepts

**Vue.js Framework Responsibility**:

Vue.js is responsible for UI rendering using HTML-based declarative templates and manipulating the application model to bind the rendered DOM to the underlying model data.

**Root Component Importance**:

Every Vue.js app requires a "root component" that serves as the container for other components, defining the app as a tree structure with components.

#### MVVM – Model-View ViewModel

**Model-View ViewModel Overview**:

- MVVM separates the user interface (view) from the business logic (model).
- View directly binds to the model, displaying parts through one-way data binding and allowing editing through two-way data binding.

**Vue.js and MVVM**:

- Vue.js focuses on the ViewModel layer of the MVVM pattern.
- It facilitates two-way data bindings between the View and the Model.

#### Vue's Reactivity System

Vue.js reactivity system supports two-way data-binding where data sources are synchronized with UI elements. When model data changes, Vue.js automatically updates the UI accordingly.

Reactive State in Vue.js refers to the data of the component model that is automatically bound to the template. Changes in reactive state are immediately reflected in the view, ensuring efficient DOM updates.

Vue.js provides the `reactive()` function as an alternative to declare reactive state. It makes objects reactive, allowing Vue to track and trigger reactivity for all properties of the object.

### Application & Component Instances

#### Application Instance

- An application instance refers to a specific occurrence of an application running on a system.
- In the context of the document, an application instance is created using the `createApp` function in Vue.js to establish a new Application Instance.

#### Root Component

The root component is essential for every Vue.js application as it serves as the main container that can hold other components as its children.

It is defined by a tree structure of components, with the object passed into createApp representing the root component.

#### Setup Function

The `setup()` function in Vue.js defines the component model, specifically the root component model of the application. It is executed once before the template is rendered and returns an object with the elements (data, functions, etc.) that the component model exposes to the template.

#### Mount

The `mount()` method in Vue.js is responsible for rendering the content of the app's root component inside a container element. It requires a "container" argument, which can be either a DOM element or a selector string. This method should always be called after all app configurations and asset registrations are completed.

### Reactivity System

#### Reactive State

- Reactive State in Vue.js refers to the data of the component model that is automatically bound to the template.
- Changes in the value of reactive state are immediately reflected in the view, as Vue.js efficiently updates the DOM when changes occur.

**ref() vs reactive()**:

- `ref()` is recommended as the primary API for declaring reactive state, especially for beginners, due to its explicit nature and avoidance of certain limitations associated with `reactive()`.
- `reactive()` is an alternative way to declare reactive state, making the object itself reactive, but it has limitations such as only working for object types and potential destructure problems.

### Options API and Composition API

**Options API**:

- Used by Vue.js 2.
- Has a more rigid structure with predefined sections like data, methods, watches, computed, etc.

**Composition API**:

- Introduced in Vue.js 3.
- Does not have a predefined structure, allowing for more flexibility in code organization.

**Main Differences**:

- Options API is more "object-oriented" while Composition API is more "functional-oriented."
- Composition API simplifies code and provides better control without relying on the automatic filling of the "this" reference.

#### Composition API Advantages

**Better Logic Reuse**:

- Clean, efficient logic reuse through Composable functions.
- Essential Vue Composition utilities can be accessed for improved reusability.

**More Flexible Code Organization**:

- Code structure is not rigid or constrained, allowing for more flexibility in organizing code.

**Better Type Inference**:

- Simplifies the use of TypeScript language and type inference in the IDE or editor.
- Composition API mainly uses plain variables and functions, which are naturally type friendly.

### Templates

#### Interpolation in Vue

**Text Interpolation**:

In Vue.js, text interpolation is done using double curly braces outside of the "tag" definition. It is not applicable to attributes and is mainly used outside of the tag definition.

**Attribute Interpolation**:

For HTML attributes in Vue.js, `v-bind` attribute interpolation or the `:` alias is used instead of text interpolation. This allows dynamic binding of attributes using JavaScript expressions.

#### Conditional Directives

**v-if Directive**:

- Creates a UI element if the expression is true.
- Can be paired with `v-else` and `v-else-if` for additional conditions.

**v-show Directive**:

- Similar to `v-if` but always creates the UI element.
- Shows the element if the expression is true and hides it if false.

#### Loop Directive

The loop directive in Vue.js is implemented using the `v-for` directive. It allows for iterating over arrays to create similar and repeatable UI elements for each item in the array. It is recommended to provide a key attribute when using the `v-for` directive.

#### Events & Two-Way Bindings

- Vue.js supports two-way data binding, enabling seamless synchronization between data sources and UI elements.
- With two-way data binding, any changes to the model data automatically update the UI, and updates in the UI reflect back to the model.
- Vue.js offers directives such as `v-on` for event handling and `v-model` for achieving two-way data binding in applications. Additionally, the `@` alias can be used as a shorthand for `v-on` to simplify event listener declarations.

#### Modifiers

Modifiers in Vue.js are special directives that can be added to events and the v-model directive.

Examples of modifiers include `.prevent`, `.stop`, `.lazy`, `.number`, and `.trim`.

These modifiers help in customizing the behavior of event handling and data binding in Vue.js.

#### Class and Style Binding

- Class and style attributes in Vue.js have special bindings that allow for dynamic changes based on conditions.
- You can bind classes to objects using the :`class` directive with conditional expressions like `isActive` and `hasError`.
- Similarly, you can bind styles to objects using the `:style` directive with dynamic values like `fontSize + 'px'`.

#### Template Refs

The `ref` attribute in Vue.js allows access to the underlying DOM elements, such as `<input ref="taskinput" ... >`. It is used to interact with the DOM elements directly within Vue.js components.

In Vue.js projects, it is recommended not to use the DOM directly (avoid using the document object) to maintain a cleaner and more efficient code structure.

### Computed Properties and Watchers

#### Computed Properties

**Computed Properties Definition**:

Computed properties in Vue.js are like reactive states whose values are determined by functions. They help simplify templates by replacing complex inline expressions with a computed property, making templates less cluttered and easier to maintain.

**Writable Computed Properties**:

By default, computed properties are getter-only (read-only). To make them writable, you need to define a setter as well. This allows you to update the computed property's value when needed.

**Computed Properties vs Methods**:

Computed properties and methods can achieve similar results, but computed properties are cached based on their reactive dependencies. This means that a computed property will only re-evaluate when its dependencies change, providing performance benefits compared to method invocations.

#### Watch

**watch() Function Overview**:

- Allows defining behavior when a reactive state changes.
- Can be used with ref, reactive objects, getter functions, or arrays of sources.

**Examples with Getter Functions**:

- Detects changes when the value returned by the getter function changes.
- Useful for scenarios where direct reactive state access is not possible.

**Deep Watchers**:

- Implicitly created when watch() is called directly on a reactive object.
- Useful for monitoring changes in nested objects within the reactive state.

**Additional Watcher Options**:

- Include concepts like eager watchers, once watchers, watchEffect, and side effect cleanup.
- For more detailed information, refer to the official Vue.js documentation on watchers.

### Component Lifecycle & Lifecycle hooks

#### Component Lifecycle

Each Vue component instance undergoes a series of initialization steps when it is created. These steps include setting up data observation, compiling the template, mounting the component to the DOM, and updating the DOM whenever data changes. Throughout this process, Vue provides lifecycle hooks—functions that are called at specific stages of the component's lifecycle. These hooks give developers the opportunity to execute custom code at different points, such as during component creation, mounting, updating, or destruction.

An example of a lifecycle hook is "mounted," which is triggered after the component has been mounted to the DOM. This stage is ideal for tasks that require the component to be rendered, such as accessing or manipulating the DOM, starting data fetching, or initializing third-party libraries.

#### Lifecycle Hook

A lifecycle hook in Vue.js functions like an event handler that executes at a specific stage in a component's lifecycle. These hooks allow developers to add custom behavior at different stages, such as when a component is created, mounted, updated, or destroyed.

**Registering a Lifecycle Hook (e.g., `onMounted`)**:

To use a lifecycle hook like `onMounted`, you register it within the component's setup function. The argument of the `onMounted` function is a callback that executes when the component reaches the "mounted" stage, indicating that the initial rendering is complete, and the DOM nodes have been created.

**Commonly Used Lifecycle Hooks**:

- `onMounted`: Triggered after the component has been mounted, meaning the initial rendering is complete, and the DOM nodes are available. It's often used for tasks like fetching data or manipulating the DOM.

- `onUpdated`: Called after the component updates its DOM tree due to a reactive state change, allowing for operations that need to respond to these updates.

- `onUnmounted`: Executed after the component has been unmounted from the DOM. This is useful for cleaning up side effects, such as clearing timers, removing event listeners, or closing server connections.
